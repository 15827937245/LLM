Camera基础:
1，常用API类介绍
CameraManger:摄像头管理类，用于打开和关闭摄像头。
CameraCharacteristics：描述摄像头的各种特性，K-V的方式来获取值，泛型。
CameraDevice:连接相机的代表，类似与以前的Camera类。
CameraCaptureSession:session类，用来向相机设备发送获取图像请求。
CaptureRequest:描述了一次操作请求
CaptureResult:描述拍照完后的结果，比如一些拍照是的值，如ISO等。
2，起预览流程代码实现
   CameraManager = context.getSystemService(Context.CAMERA_SERVICE)
   CameraManager.openCamera()->onOpened()->CameraDevice
   CameraDevice.createCaptureSession(List<Surface>)->onConfigured()->CameraCaptureSession
   CaptureRequest.Builder = CameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
   CaptureRequest.Builder.addTarget()  CameraRequest.Builder.set()  CaptureRequest = CaptureRequest.build()
   CameraCaptureSession.setRepeatingRequest(CaptureRequest)

    先获取到CameraManger类，然后调用CameraManger类中的openCamera()方法，openCamera方法中有三个参数，第一个是String类型的CameraId，
    该参数是用于打开指定摄像头的Id，第二个是打开相机的回调，在回调函数中有三个需要实现的方法，第一个是onOpened表示摄像头打开成功，且该方法中传
    入了一个参数CameraDevice，我们可以获得该摄像头的CameraDevice，第二个方法为断开连接，第三个个是连接出错。最后一个参数为Handler，用于
    指定调用的该回调的线程。此时相机的摄像头已经打开，接下来将创建session。
    创建session是通过在打开相机获得CameraDevice类来调用createCaptureSession（）来创建的。createCaptureSession中有三个参数，第一个
    是outputs我们要输出Surface的List集合，在预览中我们一般传入两个输出Surface，一个是预览的Surface另一个是imageReader的Surface，
    imageReader的Surface是为了后面拍照做准备的。在传入这两路流之前，我们先要将预览的尺寸先设定好，我们可以通过CameraId来或的相机的特性，
    再通过相机的来获得摄像头所支持的Map尺寸集合，在根据比例和屏幕的宽度选取最合适的尺寸大小设为预览界面的大小和预览的Surface大小，然后在获得
    ImageReader实例时将获取的图片大小设置为我们预览大小。此时创建session的第一个参数已经准备完毕，第二个参数为创建session的回调，该回调中有
    两个回调方法，第一个是onConfigured（），这个方法表示session创建成功，该方法有一个参数为session，因此在这里我们可以哪到session，第二个方法
    为onConfiguredFailed（）也就是常见session失败。三个参数为Handler和之前的openedCamera方法中的Handler一样，也是设定调用回调方法的指定线程。
    在创建session成功后，我们向需要获得预览的数据，所以我们需要发送持续的请求来获取连续的预览画面，我们通过之前获取的session调用setRepeatingRequest（）
    方法来发送请求，该方法中的第一个参数为CaptureRequest，我们可以通过CameraDevice.createCapture（）方法来获得CaptureRequestBuilder类，在该方法中
    需要一个参数，也就是请求模板，请求模板一共分为六种，第一种是TEMPLATE_PREVIEW用于创建预览的请求，也是我们这次要使用的模板，TEMPLATE_RECORD用于创建视屏
    录制的请求。TEMPLATE_STILL_CAPTURE用于创建一个静态图像捕获的请求，一般我们用于拍照请求。TEMPLATE_VIDEO_SNAPSHOT创建视屏录制时截图的请求，一般我们用于
    创建一个录像中带拍照的请求。TEMPLATE_ZERO_SHUTTER_LAG创建一个零快门的请求，也就是我们的快拍请求。TEMPLATE_MANUAL手动控制请求，一般我们用来作为专业模式。
    创完CaptureRequestBuilder对象后，我们设置数据输出流的对象，也就是调用addTarget方法指定输入的Surface。最后在通过build方法建造一个CaptureRequest对像。
    此时发送请求的第一个参数准备好了，第二个参数时回调，第三个也是Handler。此时预览流程就完成了。

3，拍照流程代码实现
   CameraManager = context.getSystemService(Context.CAMERA_SERVICE)
   CameraManager.openCamera()->onOpened()->CameraDevice
   CameraDevice.createCaptureSession(List<Surface>->ImageReader.getSurface preview.getSurface)->onConfigured()->CameraCaptureSession
   CaptureRequest.Builder = CameraDevice.CaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
   CameraRequest.Builder.addTarget()  CaptureRequest.Builder.set()  CaptureRequest = CaptureRequest.build()
   CameraCaptureSession.setRepeatingRequest(CaptureRequest)
   ->takePicture
   CaptureRequest.Builder = CameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE)
   CaptureRequest.Builder.addTarget()  CaptureRequest.Builder.set()  CaptureRequest = CaptureRequest.build()
   CameraCaptureSession.capture(CaptureRequest) -> ImageReader -> onImageAvailable -> src ->save()




拍照流程和预览流程相似，我们一般是先启动预览，在预览创建session时传入了两路流，一路预览流，一路拍照流，也就是ImageReader.getSurface，在点击拍照时，我们发送了一个拍照的请求
也就是调用session调用Capture（）方法，Capture方法中也有三个参数和setRepeatingRequest方法中的参数一样不过在创建CaptureRequest时使用的时TEMPLA_STAILL_CAPTURE拍照请求
在发送拍照请求后在ImageReader中的监听事件会拿到刚刚拍照的数据。
4，录像流程代码实现
   CameraManager = context.getSystemService(Context.CAMERA_SERVICE)
   CameraManager.openCamera()->onOpened()->CameraDevice
   CameraDevice.createCaptureSession(List<Surface>->MediaRecorder.getSurface preview.getSurface)->onConfigured()->CameraCaptureSession
   CaptureRequest.Builder = CameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECODE)
   CaptureRequest.Builder.addTarget()  CaptureRequest.Builder.set()  CaptureRequest = CaptureRequest.build()
   CameraCaptureSession.setRepeatingRequest(CaptureRequest)
   ->takeVideo  MediaRecorder.start() -> MediaRecorder.stop()  -> MediaRecorder.reset()




录像流程和预览流程相似，不过在录像时我们创建session传入了的数据流不一样，传的时预览流、录像流，如果我们想在录像时能拍照我们还可以传入一路拍照流，然后在创建CaptureRequest时使用相应的
模板。录像流使用了MediaRecorder.getSurface，在开始录像时我们需要调用MediaRecorder.start（）方法，结束时调用stop方法。
5,怎么打开闪光灯，关闭闪光灯
   open ->  CaptureRequest.Builder.set(CaptureRequest.FLASH_MODE,CaptureRequest.FLASH_MODE_TORCH) -> CameraCaptureSession.setRepeatingRequest(CaptureRequest.Builder.build())
   close -> CaptureRequest.Builder.set(CaptureRequest.FLASH_MODE,CaptureRequest.FLASH_MODE_OFF) ->  CameraCaptureSession.setRepeatingRequest(CaptureRequest.Builder.build())

   在创建CaptureRequest时，调用set（）方法，该方法是键值对形式，CaptureRequest.FLASH_MODE，Capture Request.FLASH_MODE_TORCH表示开OFF表示关闭
6，怎么下发对焦模式，对焦模式有哪些
  CONTROL_AF_MODE_OFF : 自动对焦程序无法控制镜头
  CONTROL_AF_MODE_AUTO ：自动对焦
  CONTROL_AF_MODE_MACRO ：微距
  CONTROL_AF_MODE_CONTINUOUS_VIDEO ：聚焦行为应适合于高质量的视频记录
  CONTROL_AF_MODE_CONTINUOUS_PICTURE ：连续修改镜头位置，以尝试提供持续对焦的图像流
  CONTROL_AF_MODE_EDOF：扩展景深（数字聚焦）模式

  下发对焦模式
  CaptureRequest.Builder.set(CaptureRequest.CONTROL_AF_MODE,CaptureRequest.CONTROL_AF_MODE_(上面的几种模式)) -> CameraCaptureSession.setRepeatingRequest(CaptureRequest.Builder.build())
在CaptureRequest
7，怎么设置iso,曝光时间
    CaptureRequest.Builder.set(CaptureRequest.SENSOR_SENSITIVITY, 100);
   	CaptureRequest.Builder.set(CaptureRequest.SENSOR_EXPOSURE_TIME, 100l);

8，怎么获取对焦状态
   CameraCaptureSession.setRepeatingRequest()-> onCaptureCompleted() -> CaptureResult
   CaptureResult.get(CaptureResult.CONTROL_AF_STATE);
9，拍照录像模式如何切换
  拍照->录像： CameraCaptureSession.close() -> ImageReader.close() -> CameraDevice.close()
     CameraManager.openCamera()->onOpened()->CameraDevice
     CameraDevice.createCaptureSession(List<Surface>->MediaRecorder.getSurface preview.getSurface)->onConfigured()->CameraCaptureSession
     CaptureRequest.Builder = CameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECODE)
     CaptureRequest.Builder.addTarget()  CaptureRequest.Builder.set()  CaptureRequest = CaptureRequest.build()
     CameraCaptureSession.setRepeatingRequest(CaptureRequest)

  录像->拍照： CameraCaptureSession.close() -> MediaRecorder.close() -> CameraDevice.close()
     CameraManager = context.getSystemService(Context.CAMERA_SERVICE)
     CameraManager.openCamera()->onOpened()->CameraDevice
     CameraDevice.createCaptureSession(List<Surface>->ImageReader.getSurface preview.getSurface)->onConfigured()->CameraCaptureSession
     CaptureRequest.Builder = CameraDevice.CaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
     CameraRequest.Builder.addTarget()  CaptureRequest.Builder.set()  CaptureRequest = CaptureRequest.build()
     CameraCaptureSession.setRepeatingRequest(CaptureRequest)

10，前后置如何切换
     CameraCaptureSession.close() -> CameraDevice.close(),
     CameraManager.openCamera(CameraId)->onOpened()->CameraDevice ->createSession

11，4:3/16:9分辨率切换如何实现
     CameraCharacteristics = cameraManager.getCameraCharacteristics(cameraId);
     CameraCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
     Size[] previewSizeMap = streamConfigurationMap.getOutputSizes(SurfaceTexture.class);
     Size[] captureSizeMap = streamConfigurationMap.getOutputSizes(ImageFormat.JPEG);
     根据屏幕的宽度和比例选择合适的尺寸->PreViewSize
     CameraCaptureSession.close() -> CameraDevice.close(),
     CameraManager.openCamera()->onOpened()->CameraDevice -> preview.setSize  surfaceTexture.setDefaultBufferSize() ->new ImageReader(PreViewSize) -> createSession
12,怎么获取小缩略图
    ImageReader.onImageAvailable() ->  ImgSrc-> srcBitmap -> smallBitmap = Bitmap.createBitmap(srcBitmap,smallSize,matrix);
13，点击缩略图进入相册如何实现
            Uri uri = Uri.fromFile(mFile);
            Intent intent = new Intent();
            intent.setAction(Intent.ACTION_VIEW);
            intent.setDataAndType(uri, "image/jpeg");
            startActivity(intent);
14，拍照方向如何设置
    镜头orientation = CameraManager.getCameraCharacteristics(cameraId).get(CameraCharacteristics.SENSOR_ORIENTATION);
    OrientationEventListener -> 手机方向的orientation
    通过计算两个orientation 得出拍照方向。
15，水印功能如何实现
    srcBitmap ->Canvas canvasNew = new Canvas(srcBitmap);
    canvasNew.drawText(StringText, beginX, beginY, paintText)
16，ImageFormat格式有哪些
                  UNKNOWN,
                  RGB_565,
                  YV12,
                  Y8,
                  Y16,
                  NV16,
                  NV21,
                  YUY2,
                  JPEG,
                  DEPTH_JPEG,
                  YUV_420_888,
                  YUV_422_888,
                  YUV_444_888,
                  FLEX_RGB_888,
                  FLEX_RGBA_8888,
                  RAW_SENSOR,
                  RAW_PRIVATE,
                  RAW10,
                  RAW12,
                  DEPTH16,
                  DEPTH_POINT_CLOUD,
                  RAW_DEPTH,
                  PRIVATE,
                  HEIC
     常用的有JPEG、YUV420_888、RAW_SENSOR
17，Surface，SurfaceTexture,ImageReader.Surface,MediaRecorder.Surface几个Surface的区别
   Surface 画布展示
   SurfaceTexture  对图像流的处理并不直接显示，而是转为 GL 外部纹理
   ImageReader.Surface 图片数据源渲染显示
   MediaRecorder.Surface 视频数据源渲染显示
18、yuv、jpeg、bitmap，YUV和NV21格式的区别
     YUV Y表示亮度 UV表示色彩，图片存放格式
     jpeg 图片压缩的一种，有损压缩
     bitmap 位图由像素点组成。
19、JNI简单介绍
   java native interface，java和c互调，一般用来集成三方算法库
20，4：3、16：9预览拉伸变形如何处理
    将预览的TextureView的宽高和SurfaceTexture的宽高设为一致。
21，自己实现的camera应用中用到几个线程
    两个一个主线程也就是UI线程，另一个是Camera线程
22，自己实现功能时碰到了哪些问题，如何解决

23，16:9和4:3哪个视角更大
    4：3
24，4:3和16:9的常用的预览尺寸多少
  1440;1080  1920:1080
25，预览尺寸，拍照尺寸，录像尺寸如何获取：
        CameraCharacteristics = cameraManager.getCameraCharacteristics(cameraId);
        CameraCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
        Size[] previewSizeMap = streamConfigurationMap.getOutputSizes(SurfaceTexture.class);
        Size[] captureSizeMap = streamConfigurationMap.getOutputSizes(ImageFormat.JPEG);
        Size[] videoSizes = streamConfigurationMap.getOutputSizes(MediaRecorder.OutputFormat.MPEG_4);
        根据屏幕的宽度和比例选择合适的尺寸->PreViewSize ImageSize VideoSize

26，创建会话创建请求之类的线程和回调线程是不是同一线程
     是
27，预览和录像的区别
    请求模板不一样，创建session传入的List不一样
28.在录像上拍照应该怎么实现
   使用CaptureRequest.TEMPLATE_VIDEO_SNAPSHOT模板，在创建session时，传入三路流数据。
29，如何获取Jpeg，YUV，Raw照片数据
    在获取ImageReader实例时，通过传入ImageReader中的ImageFormat.JPEG等传入相应的格式
30，如何在开启相机的时候判断开启的是前置摄像头
     开启相机时通过CameraCharacteristics =  CameraManager.getCameraCharacteristics(id)获得摄像头的特性。
     然后在调用CameraCharacteristics.get(CameraCharacteristics.LENS_FACING)来判断
31. MediaRecorder设置哪些参数
     首先设置
            //Initial 初始化状态，设置视频的音频源、视频源进入已初始化状态

             mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
             mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);

             //Initialized 已初始化状态 设置视频输出格式
             mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);

             //DataSourceConfigured 数据源配置状态 设置视频输出的文件 设置视频编码比率  设置视频帧率

             mMediaRecorder.setOutputFile(mFile.getPath());
             mMediaRecorder.setVideoEncodingBitRate(10000000);
             mMediaRecorder.setVideoFrameRate(30);

             //设置视频的宽高  设置视频的编码格式  设置音频的编码格式
             mMediaRecorder.setVideoSize(previewSize.getWidth(),previewSize.getHeight());
             mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);
             mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);

             mMediaRecorder.prepare();
             //就绪状态


             MediaRecorder的几种状态
             Initial：初始状态，当使用new()方法创建一个MediaRecorder对象或者调用了reset()方法时，该MediaRecorder对象处于Initial状态。在设定视频源或者音频源之后将转换为Initialized状态。另外，在除Released状态外的其它状态通过调用reset()方法都可以使MediaRecorder进入该状态。

             Initialized：已初始化状态，可以通过在Initial状态调用setAudioSource()或setVideoSource()方法进入该状态。在这个状态可以通过setOutputFormat()方法设置输出格式，此时MediaRecorder转换为DataSourceConfigured状态。另外，通过reset()方法进入Initial状态。

             DataSourceConfigured：数据源配置状态，这期间可以设定编码方式、输出文件、屏幕旋转、预览显示等等。可以在Initialized状态通过setOutputFormat()方法进入该状态。另外，可以通过reset()方法回到Initial状态，或者通过prepare()方法到达Prepared状态。

             Prepared：就绪状态，在DataSourceConfigured状态通过prepare()方法进入该状态。在这个状态可以通过start()进入录制状态。另外，可以通过reset()方法回到Initialized状态。

             Recording：录制状态，可以在Prepared状态通过调用start()方法进入该状态。另外，它可以通过stop()方法或reset()方法回到Initial状态。

             Released：释放状态（官方文档给出的词叫做Idle state 空闲状态），可以通过在Initial状态调用release()方法来进入这个状态，这时将会释放所有和MediaRecorder对象绑定的资源。

             Error：错误状态，当错误发生的时候进入这个状态，它可以通过reset()方法进入Initial状态。
32,如何获取帧率范围：
    CameraCharacteristics.control_ae_available_target_fps_ranges
33. CameraId怎么拿到
   CameraManager.getCameraIdList()获取到摄像头所有id，然后遍历
34. 怎么获取到闪关灯的状态：
        CameraCaptureSession.setRepeatingRequest()-> onCaptureCompleted() -> CaptureResult
        CaptureResult.get(CameraResult.FLASH_STATE);
35，实现连拍的API是哪个:
   CameraCaptureSession.captureBurst()
   CameraCaptureSession.setRepeatingBurst()
36,相机模板有哪些：
    CameraDevice.TEMPLATE_PREVIEW :预览模板
    CameraDevice.TEMPLATE_RECODE; 录像
    CameraDevice.TEMPLATE_STILL_CAPTURE; 拍照
    CameraDevice.TEMPLATE_VIDEO_SNAPSHOT; 录像时拍照
    CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG; 零快门
    CameraDevice.TEMPLATE_MANUAL; 手动

37,慢动作如何实现：
   setVideoFrameRate（30）；
   setCaptureFrameRate（120）；
38,前后置切换如何实现：
    CameraCaptureSession.close() -> CameraDevice.close(),
    CameraManager.openCamera(CameraId)->onOpened()->CameraDevice ->createSession
39，相机预览卡顿原因：
      内存泄露
40，bitmap缩略图，bitmap拿到的数据是从哪里来的，是不是直接从底层获取的，在哪个阶段怎么过去的数据
    bitmap数据是由ImageReader在发送拍照请求后在onImageAvailable中获取到数据，该数据是由session中传入的listSurface
    通道中传输过来的数据，然后将拿到的数据转化成bitmap
41,Java泛型在Camera中哪里遇到过
     在CameraRequest.Builder.set(key,value)就是泛型
       CameraCharacteristics.get(key)
       CaptureResult.get(key)
       创建session是的List<>集合
42,ImageReader如何创建
   ImageReader.newInstance()
43.功能实现过程实现那个功能用了最长时间，遇到了什么问题，怎么解决的

44.相机怎么实现摄像头切换（CameraID怎么获取，
怎么判断当前摄像头是前置还是后置）
   通过CameraManager.getCameraCharacteristics(CameraId)获得摄像头特性，然后根据摄像头特性的LENS_FACING获得相机是前置还是后置
45，怎么理解相机的稳定性

Android基础：
1，Android四层架构介绍：
应用层：手机上的各种运行在虚拟机上的应用。
应用框架层：由google提供应用程序开发的API框架
系统运行库层：当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用各个组件。
内核层：Android的核心系统服务基于Linux2.6内核。
2,service的杀死方式
   如BindService启动方式启动的，解绑调用unBind（）方法，解除所有与Service绑定的组件，此时Service没有绑定的组件时会调用onDestroy（）方法来结束服务。
   startService启动的服务可以在启动的组件中调用stopService（Intent i）来停止服务，在服务内可以调用stopSelf（）方法来停止。
   两种启动形式都可以关闭应用来结束服务。
3，两个Activity 之间跳转时必然会执行的是哪几个生命周期方法？
   AActivity跳转到BActivity，先是A->onPause() B->onCreate()->onStart()->onResume() A->onStop()
4，横竖屏切换生命周期怎么走
   onPause()->onStop()->onDestroy()->onCreate()->onStart()->onResume() 就是将当前的activity给结束，然后在创建一个横或竖的新的Activity。
5，点击Home键，activity生命周期怎么走
   onPause()->onStop()   然后在点击会当前的应用onRestart()-onStart()-onResume()
6，Activity怎么传递数据给Service
  可以用Intent.putExtras（）方法传递数据。然后是启动的是绑定服务的话可以在绑定的时候。
  在启动的是绑定服务时，在绑定成功后Activity可以获取到IBinder service接口，我们去实现这个IBinder接口就可以与Activity进行通信，实现IBinder接口有三种方式实现，
  第一种时IBinder的扩展类，第二种时Messager,第三种时AIDL
7,怎么去发送广播
 在组件中使用sendBroadcast（Intent intent）方法发送广播，如果发送有序广播则是调用，sendOrderedBroadcast(Intent intent),然后接受广播则是先注册一个广播接收者，
 可以是动态注册（代码注册）或是静态注册（在xml文件中注册）。
8，广播能不能被拦截
能，有序广播可以拦截，优先级高的接收者可以在接受到广播后调用abortBroadcast()将广播给拦截
9，android中如何创建Activity,Service,BroadCastReceiver,ContentProvider

10，Activity四种启动模式介绍:
    Standard：标准的启动模式，需要一个Activity就创建一个Activity实例，也是Activity默认的启动方式。
    SingeTop：单顶启动模式，当Activity处于栈顶时，此时在创建Activity就不会去重新创建Activity，而是复用位于栈顶的Activity实例对象，前提是创建的Activity是该activity对象，且该Activity不处于栈顶时还是会创建Activity实例。
    SingeTask：如果该Activity被复用时，且该Activity不位于栈顶，此时会将复用的Activity之上的其他Activity全部杀死，让后让该Activity位于栈顶。
    SingleInstance：单实例模式重新开启一个Activity栈，将这个实例放入该栈中，且该栈有且仅有这一个实例。
11，service的生命周期介绍
   startService的生命周期 ： onCreate() -> onStartCommand()-> onDestroy();
   bindService的生命周期： onCreate() -> onBind() -> onUnBind()-> onDestroy();
12，Activity的作用
  提供可视化界面及操作，与用户进行交互
13，Service的作用
   Service是一个长期运行在后台的用户组件，没有用户界面，提供后台服务，比如音乐播放器等
14，Service生命周期函数运行在哪个线程
   Service是运行在主线程的，所以service中不应该又有耗时的操作。不过IntentService运行在子线程中，不过现在已经过时。
15，启动服务或绑定服务后，服务运行在哪个进程
    运行在启动的应用进程中
16，service的启动方式
service分为两种启动方式，一个是startService另一种是bindService，第一种启动方式启动后会一直运行在后台，就算启动该服务的组件已被销毁服务也会运行在后台。
bindService启动的服务需要与组件进行绑定，绑定后实现IBinder后就可以组件与服务进行通讯，如果组件与服务解除绑定后，服务没有与其他的服务进行绑定，该服务会自动
销毁。该服务可与多个组件进行绑定。
17，处理耗时操作的服务是哪个
 intentService
18，广播的作用
  广播用于发送消息，类似与我们现实生活中的广播，广播的接受需要广播接收者进行接受
19，广播的分类
广播主要分为，普通广播（无序广播）、有序广播、本地广播、系统广播和粘性广播（已经被弃用）
20，广播的注册方式有哪些
   广播可以进行静态注册，也就是在配置文件中进行注册，也可以动态注册，也就是在代码中注册，动态注册的广播在同优先级值下比静态广播的优先级高（在有序广播下）
21，ContentProvider的作用，如何实现
   将本应用的指定的数据暴露给其他应用使用。
   1.继承ContentProvider抽象类
   2.实现onCrate、getType、insert、delete、update、query方法
   3.在清单文件中注册ContentProvider
   4.将访问途径Uri提供出去
22，常用的布局有哪些
   线性布局、帧布局、网格布局、相对布局、绝对布局
23,Android数据的四大存储方式介绍：
   SharedPreferences：是一种轻量级的存储类，它是已键值对的形式将数据保存在xml文件中，数据类型只支持float、int、String、long、boolean、StringSet类型。
   一般用于存储一些设置状态、用户名密码等较为简单的数据。
   文件存储：文件存储又分为内部存储和外部存储，内部存储存储的数据是该应用私有的，其他应用访问不到，外部存储则相反。文件存储与java的存储类似，都是通过I/O流进行文件的写入
   与读取。
   SQLite：SQLite是安卓自带的一个轻量级数据库。
   ContentProvider：用于数据交互，可以将自己的数据共享给其他应用。
   网络存储：将数据打包发送到服务器进行存储。
24，Handler的作用是什么
     线程之间的通讯
25，怎么实现主线程给子线程发消息
    主线程获取到子线程的handler对象，调用handler.sendMessage（）发送消息。
    子线程重写handlerMessage（）方法，并于子线程的Looper进行绑定。
26，怎么实现子线程给主线程发消息
子线程获取到主线的handler对象，调用handler.sendMessage()发送消息。
27，MessageQueue，Looper， Handler，Message这几个对象的作用
    MessageQueue：用于存储handler发送的消息；
    looper：遍历MessageQueue，将MessageQueue中的消息分发下去
    handler:用于发送消息和处理消。
28，一个线程里面可以有多少个Handler，有多少个looper，有多少个MessageQueue
一个线程中可以又多个handler，但只有一个Looper和MessageQueue
29，不同Handler发送消息到同一个消息队列，怎么区分是哪个handler发送的
     在Looper中会有一个Target会指向发送消息的handler对象，msg.target = this;
30，自定义VIew流程介绍
    1.继承View/ViewGroup或他们的具体实现类如Button/LinerLayout
    2.如果继承的是View组件，则需要实现onDraw方法，onDraw方法是画出组件的样式的。选择实现onMeasure（）方法，
    该方法是测量组件的宽高，我们可以通过setMeasuredDimension来设置组件的大小。
    3.如果是继承的是ViewGroup则需要实现onMeasure和onLayout，前者是测量主键的大小，后者这是设置组件摆放的位置。
31，如何获取xml定义的view的宽高
    可以通过view.getWeight（） getHeight(）来获取宽高
    在自定义view中我们可以在onMeasure方法中调用MeasureSpec.getSize()传入onMeasure中测量的宽高值
32，onMeasure,onSizeChange,onDraw的执行顺序
     先执行onMeasure在执行onSizeChange最后执行onDraw
33，MeasureSpec的作用
    可以获取到测量的宽高值和模式
34，常用动画有哪些，分别是怎么使用的
   常用的动画有三种：帧动画、补间动画和属性动画。
   帧动画:1.在drawable文件中放入需要播放的图片。
         2.在drawable文件中创建一个animation_list的xml文件，在文件中添加之前放置的图片按照顺序添加
         3.在布局中创建一个ImageView
         4.在代码中使用资源加载器去加载我们之前写的xml文件，然后获得AnimationDrawable对象，然后在用上一步创建的ImageView设置AnimationDrawable为背景。
         5.然后调用AnimationDrawable.start（）方法播放动画
   补间动画、属性动画：补间动画可以使用xml或java代码两种方式实现。他们支持四种变换：平移、缩放、旋转和透明度变换
         补间动画主要使用的是Animation类，如果用xml文件写的动画变换时，需要使用Animation工具类先去加载xml文件,然后想要播放动画的组件去调用
         startAnimation（）将刚刚获得的Animation类传进去便开始播放动画。java代码控制动画则是new一个相对用的动画变换的Animation如平移则是new一个
         TranslateAnimation（）类，里面传入平移的值。
         属性动画则是通过Animator类。Animator类通过ObjectAnimator类或ValueAnimator类去创建Animator
35，事件分发机制介绍
  当用户触摸屏幕时将会产生点击事件，一个应用中会有很多组件时一层套一层的，这个点击事件怎么能精确到哪个组件呢？
  这是就出现事件分发了。事件分发的本质就是将点击事件向莫格View进行传递并得到处理。
36，事件分发流程介绍
   实现分发首先要知道事件在哪些对象进行传递，我们一般会认为在Activity、ViewGroup和View之间传递
   一个点击事件发生后，最先传递的时Activity然后时ViewGroup最后则是View.
   当一个点击事件发生后，activity最先接受到该事件，activity中的dispatchTouchEvent方法可以控制事件是否向下分发，如果是下发着会走到
   viewGroup中的dispatchTouchEvent事件，如果事件下发则会走ViewGroup的onInterceptTouchEvent,然后如果不拦截则走到view的onTouchEvent事件，如果
   onTouchEvent不消耗事件则向上传递
37，事件冲突处理介绍，举例怎么处理
   如子view中有一个上下滑动listView他的父容器中listView是左右滑动，当在子容器中进行左右滑动时，父容器应该拦截这个事件，并处理这个事件，不让他走到子容器中
   并实现父容器的左右滑动。
38，什么是线程，什么是进程
进程是指系统中正在运行的一个应用程序，程序一旦运行就是进程，线程是程序执行的最小单位
39，什么是并发，什么是并行
并发 单核CPU交替进行不同代码块，并行 多核CPU同时进行不同代码块
40，线程的创建方式有哪些
继承Thread  实现Runnable接口 实现Callable接口
41，线程的五种状态介绍
   新建状态:线程对象被创建，还没执行start（）方法
   就绪状态：执行start（）方法后，还未被cpu给调度
   运行状态：线程处于运行状态，cpu执行该线程
   阻塞状态：线程被挂起，等待CPU重新调用
   死亡状态：线程运行结束或异常中断
42，线程常用方法作用：
   join():子线程调用该方法，父线程会线程会一直wait，直到子线程执行完毕后父线程才能执行
   sleep()：线程睡眠，睡眠期间会让出CPU执行权，但不释放锁
   interrupt()：线程中断
   yield()：线程礼让，交出CPU使用权，从运行态变为挂起状态
   wait()：线程等待，等待期间会让出COU执行权，释放锁。
   suspend()：线程挂起，不释放锁
   resume()：调用该方法的线程恢复因suspend()方法挂起的线程使之重新能够获得CPU执行
   notify()：线程唤醒，随机唤醒一个等待的线程
43,wait,notify的区别
    wait线程等待
    notify线程唤醒
44，如何停止线程
      1.使线程走run（）方法
      2.先调用sleep（）方法，然后调用interrupt（）方法
45，多线程的好处
    更加充分的利用CPU资源，提高程序运行的速度
46，什么是线程安全
    当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外额同步，
    或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的
47，什么是线程同步
   实现线程排队，防止线程同步访问公共资源造成冲突，变量需要同步，常量不需要。
   多个线程访问共享资源的代码有可能是同一份代码，也有可能是不同的代码；无论是否执行同一份代码，只要这些线程的代码访问同一份可变的共享资源，这些线程之间就需要同步
48，线程同步问题如何处理，举例处理过的问题
     一般就拿买票的例子，多个窗口卖票，卖的是同一份票，当多个线程都需要卖出一张时，也就是同时减一操作，
    可能导致数据不准确，因此在数据进行操作时需要加锁。
49，synchronized修饰同步方法和同步代码块有什么区别
     synchronized修饰同步方法，该方法是普通方法时此时锁的时当前对象，如果是静态方法则是锁的是类。
     synchronized修饰同步代码块时，锁的时Object对象，这个对象是由我们定义的，可以是当前类也可以是别的对象。
50，Android提供了常用的操作多线程的方式
       Handler，线程之间的通讯，
51，常用的设计模式有哪些，举例你写过的设计模式代码及在相机中的应用
单列模式，建造者模式，模板方法模式，观察者模式，策略模式，工厂模式，迭代器，
    在使用SharedPreferences时我使用的时单列模式
    在Camera应用中创建的CaptureRequest使用的时建造者模式
    在存储照片时，创建bitmap时使用的时工厂模式
52，什么是内存泄漏
    该被回收的对象没有被回收
53,什么是内存溢出OOM
    当申请的内存空间不足时就会报OOM，一般出现这种情况是由于内存泄露造成
54，分别介绍java四种引用
   强引用：也就是new一个对象
   弱引用
   软引用：
   虚引用：
55，举例说明哪些情况可能引起内存泄漏及内存泄漏如何解决
    比如我们我们使用单例模式创建SharedPreference工具类时我们需要传入一个Content对象，当该Content对象被销毁时，而单列模式是长生命周期的对象，
    此时会造成长生命周期的对象持有短生命周期的对象，该回收的对象不能被回收造成了内存泄露。
    解决内存泄露一般是上长生命周期的对象虚引用短生命周期的对象。
56，内存泄漏检测的工具介绍

57，ANR是什么
   应用无响应
58，ANR的原因，如何避免
    主线程执行了耗时操作，
    耗时操作执行在子线程里，使用handler去通知更新UI
59，怎么理解性能优化
     性能优化使用
60，怎么理解内存优化
61，java内存机制，堆，栈，方法区介绍
62，内存优化的优点
63，跨进程通信的方式有哪些及如何实现
64，Surface,View，SurfacaeTexture,SurfaceView，GLsurfaceview,Textureview区别
65,JNI编程介绍
    Java native interface，java和c的互调
66,MVP/MVC/MVVM介绍
67.列举一个Java多线程的例子
      tomcat接受请求
68,synchronized可以修饰什么
可以修饰方法和代码块
69,若一个线程在synchronized同步代码块里面自动wait,怎样让程序继续执行

70,synchronized修饰的内容，怎么判断作用的范围
71,你平时开发中用了哪些引用
   弱引用和强引用
72,多线程同步在哪里使用
     在多个线程对同一资源进行操作时
73,线程wait后，如何唤醒指定的线程
     使用标志位，
72,camera中哪些是观察者模式
     事件的监听、广播







